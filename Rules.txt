📋 Coding Tutorial for EExApp Project
Project Name: Energy-Efficient xApp for Joint Resource Slicing and Transmission Time Scheduling

Folder: EExApp_main

Pseudocodes:
Algorithm 1: Multi-Critic-Multi-Actor GAT PPO for O-RAN
Input: 𝛼, 𝛾, 𝜆, 𝜀, B, 𝑇, 𝐾, 𝑀
Initialize: Encoder parameter 𝜂, critic parameters 𝜙𝑖 (𝑖 ∈ C);
GAT parameter 𝜁 , actor parameters 𝜃 𝑗 ( 𝑗 ∈ M);
replay buffer D ← ∅ and bipartite graph 𝐺 = {𝑉 , 𝐸}
1: for 𝑡 = 1, . . . ,𝑇 do
2: Observe the network state 𝑠𝑡
3: Encode the state ˆ𝑠𝑡 ← Enc(𝑠𝑡 |𝜂)
4: Compute critic values v𝜙 ( ˆ𝑠𝑡 ) = {𝑣𝜙𝑖 ( ˆ𝑠𝑡 )}𝑖 ∈ C =
{𝐶𝑖 ( ˆ𝑠𝑡 |𝜙𝑖 )}𝑖 ∈ C
5: Aggregate critic values vagg ( ˆ𝑠𝑡 ) = {𝑣 𝑗 ( ˆ𝑠𝑡 )}𝑗 ∈ M =
{GAT𝑗 (𝐺, v𝜙 )}𝑗 ∈ M
6: Sample the time scheduling action 𝑎0
𝑡 ∼ 𝜋𝜃0 (𝑎0
𝑡 | ˆ𝑠𝑡 , 𝜃0)
7: Sample the network slicing action 𝑎1
𝑡 ∼ 𝜋𝜃1 (𝑎1
𝑡 | ˆ𝑠𝑡 , 𝜃1)
8: Execute the joint action 𝑎𝑡 = {𝑎0
𝑡 , 𝑎1
𝑡 } in the O-RAN envi-
ronment
9: Observe the reward 𝑟𝑡 and the next state ˆ𝑠𝑡+1
10: Store the transition {( ˆ𝑠𝑡 , 𝑎𝑡 , v𝜙 ( ˆ𝑠𝑡 ), vagg ( ˆ𝑠𝑡 ), ˆ𝑠𝑡+1, 𝑟𝑡 )} into
D
11: if 𝑡 mod 𝐾 = 0 then
12: for 𝑘 = 1, . . . , 𝑀 do
13: Sample a random minibatch experiences B
{( ˆ𝑠𝑙 , 𝑎𝑙 , v𝜙 ( ˆ𝑠𝑙 ), vagg ( ˆ𝑠𝑙 ), ˆ𝑠𝑙+1, 𝑟𝑙 )}𝑙 ∈ B
14: for 𝑖 ∈ C do
15: Compute critic values for next states 𝑣𝜙𝑖 ( ˆ𝑠𝑙+1)
16: Compute value targets 𝑦𝑖 = 𝑟𝑙 + 𝛾𝑣𝜙𝑖 ( ˆ𝑠𝑙+1)
17: Compute TD errors 𝛿𝑖 = 𝑦𝑖 − 𝑣𝜙𝑖 ( ˆ𝑠𝑙 )
18: Compute the loss for critic 𝑖
𝐿(𝜙𝑖 ) = HuberLoss(𝑣𝜙𝑖 , 𝑦𝑖 )
19: Update critic 𝑖 using gradient descent
𝜙𝑖 ← 𝜙𝑖 + 𝛼∇𝜙𝑖 𝐿(𝜙𝑖 )
20: end for
21: Aggregate critic values for next states vagg ( ˆ𝑠𝑙+1) =
{𝑣 𝑗 ( ˆ𝑠𝑙+1)}𝑗 ∈ M = {GAT𝑗 (𝐺, v𝜙 ( ˆ𝑠𝑙+1))}𝑗 ∈ M
22: for 𝑗 ∈ M do
23: Compute aggregated value targets 𝑦agg
𝑗 = 𝑟𝑙 +
𝛾𝑣 𝑗 ( ˆ𝑠𝑙+1)
24: Compute aggregated TD error 𝛿agg
𝑗 = 𝑦agg
𝑗 −
𝑣 𝑗 ( ˆ𝑠𝑙 )
25: Compute advantage 𝐴𝑙 (𝜃 𝑗 ) = 𝛿agg
𝑗 +𝛾𝜆𝐴𝑙+1 (𝜃 𝑗 )
26: Compute the policy ratio
𝑅𝑙 (𝜃 𝑗 ) = 𝜋𝜃 𝑗 (𝑎𝑗
𝑙 | ˆ𝑠𝑙 )
𝜋𝜃 𝑗,𝑜𝑙𝑑 (𝑎𝑗
𝑙 | ˆ𝑠𝑙 )
27: Compute the policy loss for actor 𝑗
𝐿(𝜃 𝑗 ) = −E[min(𝑅𝑙 (𝜃 𝑗 )𝐴𝑙 (𝜃 𝑗 ), clip((𝑅𝑙 (𝜃 𝑗 ), 1 − 𝜀, 1 + 𝜀)𝐴𝑙 (𝜃 𝑗 ))]
28: Update actor 𝑗 using gradient descent
𝜃 𝑗 ← 𝜃 𝑗 + 𝛼∇𝜃 𝑗 𝐿(𝜃 𝑗 )
29: end for
30: end for
31: Clear replay buffer D = ∅
32: end if
33: end for

________________________________________
🛠️ Step 1: DRL Agent Implementation (Python)
Folder: EExApp_main\algorithms\
________________________________________
1.1 Folder structure
EExApp_main\algorithms\
├── env.py              		# Custom Gym Environment 
├── state_encoder.py       	# GRU-based State Encoder
├── mcma_ppo.py  			# Multi-Actor Multi-Critic Model
├── gat.py           			# Graph Attention Network (GAT) for critic aggregation
├── ppo.py     				# PPO training loop (DRL agent)
└── utils.py         			# Utility functions
________________________________________
1.2 Main Components
File	Purpose
env.py			Simulates the O-RAN environment (data from database and control via file sync).
state_encoder.py	Implements GRU encoder to process network state s_t, handing variable input 
mcma_ppo.py		Multi-actor multi-critic neural network architecture.
gat.py			Aggregates critic outputs via Graph Attention Mechanism.
ppo.py			Implements PPO-based training algorithm for actors and critics.
utils.py			Normalization, reward calculation, replay buffers, and other helpers.
________________________________________
1.3 File organization
../trandata/
├── xapp_db_           # SQLite database for MAC metrics
├── KPM_UE.txt         # Text file for KPM metrics
├── slice_ctrl.bin     # Binary control file
├── ppo_model.pth      # Model state file
├── rewards.csv        # Performance metrics log
└── scores.csv         # Training progress log
	
	1) database file (xapp_db_): 
		• Used to store MAC layer metrics for UEs
		• Contains a table MAC_UE with fields:
 		  - dl_curr_tbs
 			- dl_sched_rb
 			 - pusch_snr
 			 - pucch_snr
 			 - wb_cqi
  			 - dl_mcs1
		    - ul_mcs1
 			 - phr
  			- dl_bler
  			- ul_bler
		• Queried to get the latest UE MAC metrics

	2) KPM metrics file (KPM_UE.txt):
		• Stores KPM (Key Performance Metrics) for UEs
		• Contains 8 metrics per UE:
			- ue_id
  				- DRB_pdcpSduVolumeDL
  				- DRB_pdcpSduVolumeUL
 				- DRB_RlcSduDelayDL
  				- DRB_UEThpDL
			- DRB_UEThpUL
 				- RRU_PrbTotDL
  				- RRU_PrbTotUL
		• Read in real-time to get latest KPM metrics

	3) control file (slice_ctrl.bin):
		• Control Message Format: 7 int32 fields: [slice1, slice2, slice3, a_t, b_t, c_t, flag]
			- slice1–3: PRB quotas per slice
			- a_t, b_t, c_t: active/sleep/active subframe durations 
			- flag: sync control between xApp and DRL agent (1 = read UE states)
		• Used for synchronization between the agent and environment
________________________________________
1.4 env.py - Environment Design
•	State Space:
	o	17-dimensional features per UE (10 MAC metrics + 7 KPM metrics), shape: [num_ue, 17].
	o	Normalized between 0 and 1.
•	Action Space: 6 values: 
	o	Slicing control (β_t).
	o	Time scheduling control (α_t = {a_t, b_t, c_t}).
•	Reward Function:
	o	Based on throughput, delay satisfaction, energy efficiency (following Lagrangian relaxation).
•	Synchronization:
	o	Reads from slice_ctrl.bin. Use send_action(...) to write: [slice1, slice2, slice3, a_t, b_t, c_t, flag] to slice_ctrl.bin.
	o	Uses xapp_db_ (SQLite) and KPM_UE.txt.
________________________________________
1.5 state_encoder.py - GRU Handling Variable Number of UEs
To resolve dynamic UE count vs fixed input size for PPO, GRU-based sequence encoding is used:
Step				Description
1. Padding		Zero-pad UE state vectors to a fixed max length (e.g., 10).
2. Masking		Binary mask flags valid vs padded inputs.
3. GRU Encoding	GRU outputs a fixed-size state representation for the actor/critic.

Example (in PyTorch)
max_UEs = 10
num_features = 17
UE_features = np.array(KPM+MAC data)  				# shape: [N, 17]

padded_input = torch.zeros((max_UEs, num_features))  # shape: [0, 17]
mask = torch.zeros(max_UEs)

# Fill only real UEs
num_real_ues = UE_features.shape[0]
padded_input[:num_real_ues] = torch.tensor(UE_features)
mask[:num_real_ues] = 1

# GRU expects [batch, seq_len, features]
input_tensor = padded_input.unsqueeze(0)  
gru = nn.GRU(input_size=17, hidden_size=64, batch_first=True)
output, h_n = gru(input_tensor)
fixed_embedding = h_n.squeeze(0)  # shape: [64]
________________________________________
1.6 Multi-Cric Multi-Actor Model (mcma_ppo.py)
Defines actor & critic forward passes. Returns mu/std or logits.

________________________________________
1.6 Training Loop (ppo.py)
•	PPO algorithm updates:
o	Critic: Minimize TD-error using Huber Loss.
o	Actor: Maximize clipped surrogate objective.
•	Critic outputs aggregated via GAT to inform multi-actor updates.
•	Sample actions, making the sum of three slice pertange equal to 100, sum of three subframe duration equal to 10.
•	The training follows the Algorithm 1 exactly.
________________________________________
1.7 Data Flow for Python Agent
(env.py) ← (xapp_db_, KPM_UE.txt) → real-time metrics
(env.py) → (slice_ctrl.bin) → write control actions
(agent) → (ppo.py) → training updates
________________________________________

1.8 Pseudocode for env.py (DRL Environment)
class slice_env(gym.Env):
    def __init__(self):
        Define observation space (17 dimensions: MAC + KPM)
        Define action space (combined slicing + scheduling actions)

    def initialize(user_num):
        Initialize last MAC and KPM states for all UEs

    def get_UEmac_layer_info(ue_id):
        Connect to 'xapp_db_' SQLite database
        Query latest 10 MAC metrics for the UE
        If no fresh data, fallback to previous state
        Close database connection

    def get_UEkpm_info(ue_id, user_num):
        Read last 'user_num' lines from 'KPM_UE.txt'
        Match line with the given ue_id
        If no new data or data unchanged, retry

    def get_state(ue_id, user_num):
        Call get_UEmac_layer_info(ue_id)
        Call get_UEkpm_info(ue_id, user_num)
        Normalize MAC and KPM metrics
        Return concatenated normalized state vector

    def get_all_state(user_num):
        Open 'slice_ctrl.bin'
        Wait until control flag is set (flag == 1)
        For each UE (1 to user_num):
            Call get_state(ue_id, user_num)
            Collect important MAC/KPM metrics into arrays
        Return per-UE MAC statistics

    def send_action(slice1, slice2, slice3, a_t, b_t, c_t, judge):
        Wait until control flag is 1
        Overwrite 'slice_ctrl.bin' with 6 integers:
            slice1, slice2, slice3, a_t, b_t, c_t, judge (flag)

    def reset():
        Return a random initial state

    def calculate_reward(action, user_num):
        Calculate reward based on average throughput, delay, BLER, PRB usage
        Return reward, done status

    def calculate_regret(action, user_num):
        Calculate regret (QoS violation based penalty)
        Return regret, done status
________________________________________

🛠️ Step 2: xApp Implementation - Joint resource slicing and time frame scheduling (C)
Folder: EExApp_main\examples\xApp\c\ctrl\
Reference xApp: \xSlice_Paper-main\examples\xApp\c\ctrl\xapp_peihao.c
________________________________________
2.1 Folder Structure
EExApp_main\examples\xApp\c\ctrl\
├── eexapp.c       # Your custom O-RAN xApp

________________________________________
2.2 Main Responsibilities of eexapp.c
Task	                        Description
Network Metric Monitoring	    Collect UE-level KPM and MAC metrics via E2 connection. KPM Data Collection: implement via sm_cb_kpm() callback; Continue writing to KPM_UE.txt for agent reading. MAC Data: Continue monitoring with sm_cb_mac() callback
File Writing				    Save real-time UE metrics into KPM_UE.txt.
Joint Control				    Read DRL control actions from slice_ctrl.bin and apply:
- Slicing Control			    Dynamically adjust PRB quotas per slice.
- Transmission Scheduling	    Dynamically control RU active-sleep-active periods within each 10 ms frame.
Synchronization	Use control flags from slice_ctrl.bin for agent-xApp coordination.
Apply slicing via FlexRIC E2SM-RC reuse the reference xApp coding using gen_rrm_policy_ratio_group() and control_sm_xapp_api()
Implement time scheduling logic (RU control) inside 10 ms (10 subframes) control loop:
if (sf_counter < a_t || (sf_counter >= a_t + b_t && sf_counter < a_t + b_t + c_t)) {
    // Normal PRB allocation
    apply_slicing(slice1, slice2, slice3);
} else {
    // Dummy allocation (e.g., zero or minimal PRBs) → simulate RU sleep
    apply_slicing(1, 1, 1); // or 0, 0, 0
}

________________________________________
2.3 Updated slice_ctrl.bin Structure
Index	Field	Meaning
0		Slice 1 PRB Quota	
1		Slice 2 PRB Quota	
2		Slice 3 PRB Quota	
3		Active Subframes 1 (a_t)	
4		Sleep Subframes (b_t)	
5		Active Subframes 2 (c_t)	
6		Control Flag	
________________________________________
2.4 Resource Slicing Policy
follow the flow from \EExApp_main\examples\xApp\c\ctrl\xapp_peihao.c
1) initialization and setup
// Main initialization
int main(int argc, char *argv[]) {
    // Initialize framework and xApp API
    fr_args_t args = init_fr_args(argc, argv);
    init_xapp_api(&args);
    
    // Get connected E2 nodes
    e2_node_arr_xapp_t nodes = e2_nodes_xapp_api();
    assert(nodes.len > 0);
}
2) Slice Configuration Structure
// Define slice types and parameters
typedef enum {
    RRM_Policy_Ratio_List_8_4_3_6 = 1,
    RRM_Policy_Ratio_Group_8_4_3_6 = 2,
    RRM_Policy_8_4_3_6 = 3,
    RRM_Policy_Member_List_8_4_3_6 = 4,
    RRM_Policy_Member_8_4_3_6 = 5,
    PLMN_Identity_8_4_3_6 = 6,
    S_NSSAI_8_4_3_6 = 7,
    SST_8_4_3_6 = 8,
    SD_8_4_3_6 = 9,
    Min_PRB_Policy_Ratio_8_4_3_6 = 10,
    Max_PRB_Policy_Ratio_8_4_3_6 = 11,
    Dedicated_PRB_Policy_Ratio_8_4_3_6 = 12,
} slice_level_PRB_quota_param_id_e;
3) slice control loop
while(1) {
    // Initialize control request
    rc_ctrl_req_data_t rc_ctrl = {0};
    ue_id_e2sm_t ue_id = gen_rc_ue_id(GNB_UE_ID_E2SM);

    // Create control header and message
    rc_ctrl.hdr = gen_rc_ctrl_hdr(FORMAT_1_E2SM_RC_CTRL_HDR, ue_id, 2, Slice_level_PRB_quotal_7_6_3_1);
    rc_ctrl.msg = gen_rc_ctrl_msg(FORMAT_1_E2SM_RC_CTRL_MSG);

    // Send control to all connected nodes
    for(size_t i = 0; i < nodes.len; ++i) {
        control_sm_xapp_api(&nodes.n[i].id, SM_RC_ID, &rc_ctrl);
    }
}
4) Slice Resource Allocation
// Read slice control parameters from file
int numbers[4];
FILE *file = fopen("flexric/trandata/slice_ctrl.bin", "rb+");
fread(numbers, sizeof(int), 4, file);

// Configure three slices with different parameters
const char* sst_str[] = {"1", "1", "1"};  // Slice/Service Type
const char* sd_str[] = {"1", "5", "9"};   // Slice Differentiation

// PRB ratios for each slice
int dedicated_ratio_prb[] = {numbers[0], numbers[1], numbers[2]};
int Max_PRB_Ratio[] = {80, 80, 80};
int Min_PRB_Ratio[] = {20, 20, 80};

5) Policy Generation
// Generate policy ratio group for each slice
void gen_rrm_policy_ratio_group(lst_ran_param_t* RRM_Policy_Ratio_Group,
                               const char* sst_str,
                               const char* sd_str,
                               int min_ratio_prb,
                               int dedicated_ratio_prb,
                               int max_ratio_prb) {
    // Set up PLMN Identity
    // Configure S-NSSAI (SST and SD)
    // Set PRB policy ratios (min, max, dedicated)
}

6) Monitoring and Metrics Collection
// MAC layer metrics collection
void sm_cb_mac(sm_ag_if_rd_t const* rd) {
    // Collect MAC layer statistics
    // Calculate latency
    // Process metrics
}

// KPM (Key Performance Metrics) collection
void sm_cb_kpm(sm_ag_if_rd_t const* rd) {
    // Collect UE performance metrics
    // Process measurements
    // Log metrics to file
}

7) Resource Control Flow:
The xApp initializes and connects to E2 nodes
It reads slice control parameters from slice_ctrl.bin
For each slice:
	Configures PLMN Identity
	Sets S-NSSAI parameters (SST and SD)
	Defines PRB allocation ratios (min, max, dedicated)
Generates control messages for each node
Continuously monitors performance metrics:
	MAC layer statistics
	KPM measurements
	UE performance metrics
Adjusts resource allocation based on the collected metrics

8) Key Features:
Supports three types of slices (eMBB, URLLC, mMTC)
Dynamic PRB allocation with minimum and maximum ratios
Real-time performance monitoring
Inter-slice resource management
Support for multiple E2 nodes

9) File Operations:
Reads slice control parameters from slice_ctrl.bin
Writes KPM metrics to KPM_UE.txt
Logs MAC layer metrics
Maintains control flags for resource allocation
________________________________________
2.4 Transmission Time Scheduling Policy
•	Each NR frame (10 ms) has 10 subframes.
•	DRL agent decides durations:
o	a_t subframes active
o	b_t subframes sleeping
o	c_t subframes active
•	eexapp.c dynamically adjusts resource scheduling based on current phase:
o	Normal Resource Allocation during a_t and c_t
o	Dummy Allocation during b_t (sleep phase), simulate RU sleep (e.g., set slice quotas very low or disable)
____________________________________
2.6 Pseudocode for eexapp.c (xApp C Implementation)
main():
    Initialize xApp framework (init_xapp_api)
    Connect to E2 nodes (e2_nodes_xapp_api)
    Setup KPM service model (for writing KPM_UE.txt)
    Setup MAC service model (for monitoring MAC layer stats)
    
    Initialize file writer for 'KPM_UE.txt'
    Initialize slice control reader for 'slice_ctrl.bin'

    Declare variables:
        int slice_quota[3];
        int a_t, b_t, c_t;
        int control_flag;
        int sf_counter = 0;

    Loop forever:
        Read KPM metrics from connected UEs
        Write KPM metrics to 'KPM_UE.txt'
        
        If control flag in 'slice_ctrl.bin' == 1:
            Read new values:
                slice1, slice2, slice3, a_t, b_t, c_t, control_flag

        Apply control based on sf_counter:
            if (sf_counter < a_t):
                Apply PRB slicing normally (use slice_quota values)
            else if (sf_counter < a_t + b_t):
                Minimize PRB allocations (simulate RU sleep mode)
            else if (sf_counter < a_t + b_t + c_t):
                Resume normal PRB allocations
            else:
                Reset sf_counter = 0

        sf_counter += 1
        Sleep for 1 ms (simulate next subframe)

exit_handler():
    Free allocated resources
________________________________________
# 📈 Stage 3: gNB (xSlice_gNB) Integration

________________________________________
📈 Overall Data Flow of EExApp_main
1. xApp (eexapp.c) ↔ ../trandata/ (files) ↔ env.py (DRL Environment)
    ↓                                          ↑
Real-time Metrics        Joint Actions (Slice + Time Scheduling)
________________________________________

________________________________________
supplement:

1. PRBs allocated for three slices should be integers using Floor and ceiling functions

________________________________________
Design Flow:
1. First Phase: DRL Agent
# 1. Enhance env.py
- Add proper error handling
- Implement state normalization
- Add logging
- Add proper cleanup

# 2. Enhance state_encoder.py
- Add batch processing
- Implement masking
- Add attention mechanism

# 3. Enhance mcma_ppo.py
- Add actor-critic architecture
- Implement GAT
- Add action sampling
- Add value function

# 4. Enhance gat.py
- Add multi-head attention
- Implement graph construction
- Add layer normalization
- Add residual connections

# 5. Enhance ppo.py
- Add PPO clipping
- Implement GAE
- Add value function loss
- Add entropy bonus

2. Second Phase: xApp

3. Third Phase: gNB Implementation
// 1. Create resource slicing control
- Implement PRB allocation
- Add QoS monitoring
- Add proper error handling

// 2. Create transmission time scheduling
- Implement active/sleep periods
- Add proper synchronization
- Add proper error handling

// 3. Create monitoring system
- Add KPM collection
- Add MAC metrics collection
- Add proper logging