ğŸ“‹ Coding Tutorial for EExApp Project
Project Name: Energy-Efficient xApp for Joint Resource Slicing and Transmission Time Scheduling

Folder: EExApp_main

Pseudocodes:
Algorithm 1: Multi-Critic-Multi-Actor GAT PPO for O-RAN
Input: ğ›¼, ğ›¾, ğœ†, ğœ€, B, ğ‘‡, ğ¾, ğ‘€
Initialize: Encoder parameter ğœ‚, critic parameters ğœ™ğ‘– (ğ‘– âˆˆ C);
GAT parameter ğœ , actor parameters ğœƒ ğ‘— ( ğ‘— âˆˆ M);
replay buffer D â† âˆ… and bipartite graph ğº = {ğ‘‰ , ğ¸}
1: for ğ‘¡ = 1, . . . ,ğ‘‡ do
2: Observe the network state ğ‘ ğ‘¡
3: Encode the state Ë†ğ‘ ğ‘¡ â† Enc(ğ‘ ğ‘¡ |ğœ‚)
4: Compute critic values vğœ™ ( Ë†ğ‘ ğ‘¡ ) = {ğ‘£ğœ™ğ‘– ( Ë†ğ‘ ğ‘¡ )}ğ‘– âˆˆ C =
{ğ¶ğ‘– ( Ë†ğ‘ ğ‘¡ |ğœ™ğ‘– )}ğ‘– âˆˆ C
5: Aggregate critic values vagg ( Ë†ğ‘ ğ‘¡ ) = {ğ‘£ ğ‘— ( Ë†ğ‘ ğ‘¡ )}ğ‘— âˆˆ M =
{GATğ‘— (ğº, vğœ™ )}ğ‘— âˆˆ M
6: Sample the time scheduling action ğ‘0
ğ‘¡ âˆ¼ ğœ‹ğœƒ0 (ğ‘0
ğ‘¡ | Ë†ğ‘ ğ‘¡ , ğœƒ0)
7: Sample the network slicing action ğ‘1
ğ‘¡ âˆ¼ ğœ‹ğœƒ1 (ğ‘1
ğ‘¡ | Ë†ğ‘ ğ‘¡ , ğœƒ1)
8: Execute the joint action ğ‘ğ‘¡ = {ğ‘0
ğ‘¡ , ğ‘1
ğ‘¡ } in the O-RAN envi-
ronment
9: Observe the reward ğ‘Ÿğ‘¡ and the next state Ë†ğ‘ ğ‘¡+1
10: Store the transition {( Ë†ğ‘ ğ‘¡ , ğ‘ğ‘¡ , vğœ™ ( Ë†ğ‘ ğ‘¡ ), vagg ( Ë†ğ‘ ğ‘¡ ), Ë†ğ‘ ğ‘¡+1, ğ‘Ÿğ‘¡ )} into
D
11: if ğ‘¡ mod ğ¾ = 0 then
12: for ğ‘˜ = 1, . . . , ğ‘€ do
13: Sample a random minibatch experiences B
{( Ë†ğ‘ ğ‘™ , ğ‘ğ‘™ , vğœ™ ( Ë†ğ‘ ğ‘™ ), vagg ( Ë†ğ‘ ğ‘™ ), Ë†ğ‘ ğ‘™+1, ğ‘Ÿğ‘™ )}ğ‘™ âˆˆ B
14: for ğ‘– âˆˆ C do
15: Compute critic values for next states ğ‘£ğœ™ğ‘– ( Ë†ğ‘ ğ‘™+1)
16: Compute value targets ğ‘¦ğ‘– = ğ‘Ÿğ‘™ + ğ›¾ğ‘£ğœ™ğ‘– ( Ë†ğ‘ ğ‘™+1)
17: Compute TD errors ğ›¿ğ‘– = ğ‘¦ğ‘– âˆ’ ğ‘£ğœ™ğ‘– ( Ë†ğ‘ ğ‘™ )
18: Compute the loss for critic ğ‘–
ğ¿(ğœ™ğ‘– ) = HuberLoss(ğ‘£ğœ™ğ‘– , ğ‘¦ğ‘– )
19: Update critic ğ‘– using gradient descent
ğœ™ğ‘– â† ğœ™ğ‘– + ğ›¼âˆ‡ğœ™ğ‘– ğ¿(ğœ™ğ‘– )
20: end for
21: Aggregate critic values for next states vagg ( Ë†ğ‘ ğ‘™+1) =
{ğ‘£ ğ‘— ( Ë†ğ‘ ğ‘™+1)}ğ‘— âˆˆ M = {GATğ‘— (ğº, vğœ™ ( Ë†ğ‘ ğ‘™+1))}ğ‘— âˆˆ M
22: for ğ‘— âˆˆ M do
23: Compute aggregated value targets ğ‘¦agg
ğ‘— = ğ‘Ÿğ‘™ +
ğ›¾ğ‘£ ğ‘— ( Ë†ğ‘ ğ‘™+1)
24: Compute aggregated TD error ğ›¿agg
ğ‘— = ğ‘¦agg
ğ‘— âˆ’
ğ‘£ ğ‘— ( Ë†ğ‘ ğ‘™ )
25: Compute advantage ğ´ğ‘™ (ğœƒ ğ‘— ) = ğ›¿agg
ğ‘— +ğ›¾ğœ†ğ´ğ‘™+1 (ğœƒ ğ‘— )
26: Compute the policy ratio
ğ‘…ğ‘™ (ğœƒ ğ‘— ) = ğœ‹ğœƒ ğ‘— (ğ‘ğ‘—
ğ‘™ | Ë†ğ‘ ğ‘™ )
ğœ‹ğœƒ ğ‘—,ğ‘œğ‘™ğ‘‘ (ğ‘ğ‘—
ğ‘™ | Ë†ğ‘ ğ‘™ )
27: Compute the policy loss for actor ğ‘—
ğ¿(ğœƒ ğ‘— ) = âˆ’E[min(ğ‘…ğ‘™ (ğœƒ ğ‘— )ğ´ğ‘™ (ğœƒ ğ‘— ), clip((ğ‘…ğ‘™ (ğœƒ ğ‘— ), 1 âˆ’ ğœ€, 1 + ğœ€)ğ´ğ‘™ (ğœƒ ğ‘— ))]
28: Update actor ğ‘— using gradient descent
ğœƒ ğ‘— â† ğœƒ ğ‘— + ğ›¼âˆ‡ğœƒ ğ‘— ğ¿(ğœƒ ğ‘— )
29: end for
30: end for
31: Clear replay buffer D = âˆ…
32: end if
33: end for

________________________________________
ğŸ› ï¸ Step 1: DRL Agent Implementation (Python)
Folder: EExApp_main\algorithms\
________________________________________
1.1 Folder structure
EExApp_main\algorithms\
â”œâ”€â”€ env.py              		# Custom Gym Environment 
â”œâ”€â”€ state_encoder.py       	# GRU-based State Encoder
â”œâ”€â”€ mcma_ppo.py  			# Multi-Actor Multi-Critic Model
â”œâ”€â”€ gat.py           			# Graph Attention Network (GAT) for critic aggregation
â”œâ”€â”€ ppo.py     				# PPO training loop (DRL agent)
â””â”€â”€ utils.py         			# Utility functions
________________________________________
1.2 Main Components
File	Purpose
env.py			Simulates the O-RAN environment (data from database and control via file sync).
state_encoder.py	Implements GRU encoder to process network state s_t, handing variable input 
mcma_ppo.py		Multi-actor multi-critic neural network architecture.
gat.py			Aggregates critic outputs via Graph Attention Mechanism.
ppo.py			Implements PPO-based training algorithm for actors and critics.
utils.py			Normalization, reward calculation, replay buffers, and other helpers.
________________________________________
1.3 File organization
../trandata/
â”œâ”€â”€ xapp_db_           # SQLite database for MAC metrics
â”œâ”€â”€ KPM_UE.txt         # Text file for KPM metrics
â”œâ”€â”€ slice_ctrl.bin     # Binary control file
â”œâ”€â”€ ppo_model.pth      # Model state file
â”œâ”€â”€ rewards.csv        # Performance metrics log
â””â”€â”€ scores.csv         # Training progress log
	
	1) database file (xapp_db_): 
		â€¢ Used to store MAC layer metrics for UEs
		â€¢ Contains a table MAC_UE with fields:
 		  - dl_curr_tbs
 			- dl_sched_rb
 			 - pusch_snr
 			 - pucch_snr
 			 - wb_cqi
  			 - dl_mcs1
		    - ul_mcs1
 			 - phr
  			- dl_bler
  			- ul_bler
		â€¢ Queried to get the latest UE MAC metrics

	2) KPM metrics file (KPM_UE.txt):
		â€¢ Stores KPM (Key Performance Metrics) for UEs
		â€¢ Contains 8 metrics per UE:
			- ue_id
  				- DRB_pdcpSduVolumeDL
  				- DRB_pdcpSduVolumeUL
 				- DRB_RlcSduDelayDL
  				- DRB_UEThpDL
			- DRB_UEThpUL
 				- RRU_PrbTotDL
  				- RRU_PrbTotUL
		â€¢ Read in real-time to get latest KPM metrics

	3) control file (slice_ctrl.bin):
		â€¢ Control Message Format: 7 int32 fields: [slice1, slice2, slice3, a_t, b_t, c_t, flag]
			- slice1â€“3: PRB quotas per slice
			- a_t, b_t, c_t: active/sleep/active subframe durations 
			- flag: sync control between xApp and DRL agent (1 = read UE states)
		â€¢ Used for synchronization between the agent and environment
________________________________________
1.4 env.py - Environment Design
â€¢	State Space:
	o	17-dimensional features per UE (10 MAC metrics + 7 KPM metrics), shape: [num_ue, 17].
	o	Normalized between 0 and 1.
â€¢	Action Space: 6 values: 
	o	Slicing control (Î²_t).
	o	Time scheduling control (Î±_t = {a_t, b_t, c_t}).
â€¢	Reward Function:
	o	Based on throughput, delay satisfaction, energy efficiency (following Lagrangian relaxation).
â€¢	Synchronization:
	o	Reads from slice_ctrl.bin. Use send_action(...) to write: [slice1, slice2, slice3, a_t, b_t, c_t, flag] to slice_ctrl.bin.
	o	Uses xapp_db_ (SQLite) and KPM_UE.txt.
________________________________________
1.5 state_encoder.py - GRU Handling Variable Number of UEs
To resolve dynamic UE count vs fixed input size for PPO, GRU-based sequence encoding is used:
Step				Description
1. Padding		Zero-pad UE state vectors to a fixed max length (e.g., 10).
2. Masking		Binary mask flags valid vs padded inputs.
3. GRU Encoding	GRU outputs a fixed-size state representation for the actor/critic.

Example (in PyTorch)
max_UEs = 10
num_features = 17
UE_features = np.array(KPM+MAC data)  				# shape: [N, 17]

padded_input = torch.zeros((max_UEs, num_features))  # shape: [0, 17]
mask = torch.zeros(max_UEs)

# Fill only real UEs
num_real_ues = UE_features.shape[0]
padded_input[:num_real_ues] = torch.tensor(UE_features)
mask[:num_real_ues] = 1

# GRU expects [batch, seq_len, features]
input_tensor = padded_input.unsqueeze(0)  
gru = nn.GRU(input_size=17, hidden_size=64, batch_first=True)
output, h_n = gru(input_tensor)
fixed_embedding = h_n.squeeze(0)  # shape: [64]
________________________________________
1.6 Multi-Cric Multi-Actor Model (mcma_ppo.py)
Defines actor & critic forward passes. Returns mu/std or logits.

________________________________________
1.6 Training Loop (ppo.py)
â€¢	PPO algorithm updates:
o	Critic: Minimize TD-error using Huber Loss.
o	Actor: Maximize clipped surrogate objective.
â€¢	Critic outputs aggregated via GAT to inform multi-actor updates.
â€¢	Sample actions, making the sum of three slice pertange equal to 100, sum of three subframe duration equal to 10.
â€¢	The training follows the Algorithm 1 exactly.
________________________________________
1.7 Data Flow for Python Agent
(env.py) â† (xapp_db_, KPM_UE.txt) â†’ real-time metrics
(env.py) â†’ (slice_ctrl.bin) â†’ write control actions
(agent) â†’ (ppo.py) â†’ training updates
________________________________________

1.8 Pseudocode for env.py (DRL Environment)
class slice_env(gym.Env):
    def __init__(self):
        Define observation space (17 dimensions: MAC + KPM)
        Define action space (combined slicing + scheduling actions)

    def initialize(user_num):
        Initialize last MAC and KPM states for all UEs

    def get_UEmac_layer_info(ue_id):
        Connect to 'xapp_db_' SQLite database
        Query latest 10 MAC metrics for the UE
        If no fresh data, fallback to previous state
        Close database connection

    def get_UEkpm_info(ue_id, user_num):
        Read last 'user_num' lines from 'KPM_UE.txt'
        Match line with the given ue_id
        If no new data or data unchanged, retry

    def get_state(ue_id, user_num):
        Call get_UEmac_layer_info(ue_id)
        Call get_UEkpm_info(ue_id, user_num)
        Normalize MAC and KPM metrics
        Return concatenated normalized state vector

    def get_all_state(user_num):
        Open 'slice_ctrl.bin'
        Wait until control flag is set (flag == 1)
        For each UE (1 to user_num):
            Call get_state(ue_id, user_num)
            Collect important MAC/KPM metrics into arrays
        Return per-UE MAC statistics

    def send_action(slice1, slice2, slice3, a_t, b_t, c_t, judge):
        Wait until control flag is 1
        Overwrite 'slice_ctrl.bin' with 6 integers:
            slice1, slice2, slice3, a_t, b_t, c_t, judge (flag)

    def reset():
        Return a random initial state

    def calculate_reward(action, user_num):
        Calculate reward based on average throughput, delay, BLER, PRB usage
        Return reward, done status

    def calculate_regret(action, user_num):
        Calculate regret (QoS violation based penalty)
        Return regret, done status
________________________________________

ğŸ› ï¸ Step 2: xApp Implementation - Joint resource slicing and time frame scheduling (C)
Folder: EExApp_main\examples\xApp\c\ctrl\
Reference xApp: \xSlice_Paper-main\examples\xApp\c\ctrl\xapp_peihao.c
________________________________________
2.1 Folder Structure
EExApp_main\examples\xApp\c\ctrl\
â”œâ”€â”€ eexapp.c       # Your custom O-RAN xApp

________________________________________
2.2 Main Responsibilities of eexapp.c
Task	                        Description
Network Metric Monitoring	    Collect UE-level KPM and MAC metrics via E2 connection. KPM Data Collection: implement via sm_cb_kpm() callback; Continue writing to KPM_UE.txt for agent reading. MAC Data: Continue monitoring with sm_cb_mac() callback
File Writing				    Save real-time UE metrics into KPM_UE.txt.
Joint Control				    Read DRL control actions from slice_ctrl.bin and apply:
- Slicing Control			    Dynamically adjust PRB quotas per slice.
- Transmission Scheduling	    Dynamically control RU active-sleep-active periods within each 10 ms frame.
Synchronization	Use control flags from slice_ctrl.bin for agent-xApp coordination.
Apply slicing via FlexRIC E2SM-RC reuse the reference xApp coding using gen_rrm_policy_ratio_group() and control_sm_xapp_api()
Implement time scheduling logic (RU control) inside 10 ms (10 subframes) control loop:
if (sf_counter < a_t || (sf_counter >= a_t + b_t && sf_counter < a_t + b_t + c_t)) {
    // Normal PRB allocation
    apply_slicing(slice1, slice2, slice3);
} else {
    // Dummy allocation (e.g., zero or minimal PRBs) â†’ simulate RU sleep
    apply_slicing(1, 1, 1); // or 0, 0, 0
}

________________________________________
2.3 Updated slice_ctrl.bin Structure
Index	Field	Meaning
0		Slice 1 PRB Quota	
1		Slice 2 PRB Quota	
2		Slice 3 PRB Quota	
3		Active Subframes 1 (a_t)	
4		Sleep Subframes (b_t)	
5		Active Subframes 2 (c_t)	
6		Control Flag	
________________________________________
2.4 Resource Slicing Policy
follow the flow from \EExApp_main\examples\xApp\c\ctrl\xapp_peihao.c
1) initialization and setup
// Main initialization
int main(int argc, char *argv[]) {
    // Initialize framework and xApp API
    fr_args_t args = init_fr_args(argc, argv);
    init_xapp_api(&args);
    
    // Get connected E2 nodes
    e2_node_arr_xapp_t nodes = e2_nodes_xapp_api();
    assert(nodes.len > 0);
}
2) Slice Configuration Structure
// Define slice types and parameters
typedef enum {
    RRM_Policy_Ratio_List_8_4_3_6 = 1,
    RRM_Policy_Ratio_Group_8_4_3_6 = 2,
    RRM_Policy_8_4_3_6 = 3,
    RRM_Policy_Member_List_8_4_3_6 = 4,
    RRM_Policy_Member_8_4_3_6 = 5,
    PLMN_Identity_8_4_3_6 = 6,
    S_NSSAI_8_4_3_6 = 7,
    SST_8_4_3_6 = 8,
    SD_8_4_3_6 = 9,
    Min_PRB_Policy_Ratio_8_4_3_6 = 10,
    Max_PRB_Policy_Ratio_8_4_3_6 = 11,
    Dedicated_PRB_Policy_Ratio_8_4_3_6 = 12,
} slice_level_PRB_quota_param_id_e;
3) slice control loop
while(1) {
    // Initialize control request
    rc_ctrl_req_data_t rc_ctrl = {0};
    ue_id_e2sm_t ue_id = gen_rc_ue_id(GNB_UE_ID_E2SM);

    // Create control header and message
    rc_ctrl.hdr = gen_rc_ctrl_hdr(FORMAT_1_E2SM_RC_CTRL_HDR, ue_id, 2, Slice_level_PRB_quotal_7_6_3_1);
    rc_ctrl.msg = gen_rc_ctrl_msg(FORMAT_1_E2SM_RC_CTRL_MSG);

    // Send control to all connected nodes
    for(size_t i = 0; i < nodes.len; ++i) {
        control_sm_xapp_api(&nodes.n[i].id, SM_RC_ID, &rc_ctrl);
    }
}
4) Slice Resource Allocation
// Read slice control parameters from file
int numbers[4];
FILE *file = fopen("flexric/trandata/slice_ctrl.bin", "rb+");
fread(numbers, sizeof(int), 4, file);

// Configure three slices with different parameters
const char* sst_str[] = {"1", "1", "1"};  // Slice/Service Type
const char* sd_str[] = {"1", "5", "9"};   // Slice Differentiation

// PRB ratios for each slice
int dedicated_ratio_prb[] = {numbers[0], numbers[1], numbers[2]};
int Max_PRB_Ratio[] = {80, 80, 80};
int Min_PRB_Ratio[] = {20, 20, 80};

5) Policy Generation
// Generate policy ratio group for each slice
void gen_rrm_policy_ratio_group(lst_ran_param_t* RRM_Policy_Ratio_Group,
                               const char* sst_str,
                               const char* sd_str,
                               int min_ratio_prb,
                               int dedicated_ratio_prb,
                               int max_ratio_prb) {
    // Set up PLMN Identity
    // Configure S-NSSAI (SST and SD)
    // Set PRB policy ratios (min, max, dedicated)
}

6) Monitoring and Metrics Collection
// MAC layer metrics collection
void sm_cb_mac(sm_ag_if_rd_t const* rd) {
    // Collect MAC layer statistics
    // Calculate latency
    // Process metrics
}

// KPM (Key Performance Metrics) collection
void sm_cb_kpm(sm_ag_if_rd_t const* rd) {
    // Collect UE performance metrics
    // Process measurements
    // Log metrics to file
}

7) Resource Control Flow:
The xApp initializes and connects to E2 nodes
It reads slice control parameters from slice_ctrl.bin
For each slice:
	Configures PLMN Identity
	Sets S-NSSAI parameters (SST and SD)
	Defines PRB allocation ratios (min, max, dedicated)
Generates control messages for each node
Continuously monitors performance metrics:
	MAC layer statistics
	KPM measurements
	UE performance metrics
Adjusts resource allocation based on the collected metrics

8) Key Features:
Supports three types of slices (eMBB, URLLC, mMTC)
Dynamic PRB allocation with minimum and maximum ratios
Real-time performance monitoring
Inter-slice resource management
Support for multiple E2 nodes

9) File Operations:
Reads slice control parameters from slice_ctrl.bin
Writes KPM metrics to KPM_UE.txt
Logs MAC layer metrics
Maintains control flags for resource allocation
________________________________________
2.4 Transmission Time Scheduling Policy
â€¢	Each NR frame (10 ms) has 10 subframes.
â€¢	DRL agent decides durations:
o	a_t subframes active
o	b_t subframes sleeping
o	c_t subframes active
â€¢	eexapp.c dynamically adjusts resource scheduling based on current phase:
o	Normal Resource Allocation during a_t and c_t
o	Dummy Allocation during b_t (sleep phase), simulate RU sleep (e.g., set slice quotas very low or disable)
____________________________________
2.6 Pseudocode for eexapp.c (xApp C Implementation)
main():
    Initialize xApp framework (init_xapp_api)
    Connect to E2 nodes (e2_nodes_xapp_api)
    Setup KPM service model (for writing KPM_UE.txt)
    Setup MAC service model (for monitoring MAC layer stats)
    
    Initialize file writer for 'KPM_UE.txt'
    Initialize slice control reader for 'slice_ctrl.bin'

    Declare variables:
        int slice_quota[3];
        int a_t, b_t, c_t;
        int control_flag;
        int sf_counter = 0;

    Loop forever:
        Read KPM metrics from connected UEs
        Write KPM metrics to 'KPM_UE.txt'
        
        If control flag in 'slice_ctrl.bin' == 1:
            Read new values:
                slice1, slice2, slice3, a_t, b_t, c_t, control_flag

        Apply control based on sf_counter:
            if (sf_counter < a_t):
                Apply PRB slicing normally (use slice_quota values)
            else if (sf_counter < a_t + b_t):
                Minimize PRB allocations (simulate RU sleep mode)
            else if (sf_counter < a_t + b_t + c_t):
                Resume normal PRB allocations
            else:
                Reset sf_counter = 0

        sf_counter += 1
        Sleep for 1 ms (simulate next subframe)

exit_handler():
    Free allocated resources
________________________________________
# ğŸ“ˆ Stage 3: gNB (xSlice_gNB) Integration

________________________________________
ğŸ“ˆ Overall Data Flow of EExApp_main
1. xApp (eexapp.c) â†” ../trandata/ (files) â†” env.py (DRL Environment)
    â†“                                          â†‘
Real-time Metrics        Joint Actions (Slice + Time Scheduling)
________________________________________

________________________________________
supplement:

1. PRBs allocated for three slices should be integers using Floor and ceiling functions

________________________________________
Design Flow:
1. First Phase: DRL Agent
# 1. Enhance env.py
- Add proper error handling
- Implement state normalization
- Add logging
- Add proper cleanup

# 2. Enhance state_encoder.py
- Add batch processing
- Implement masking
- Add attention mechanism

# 3. Enhance mcma_ppo.py
- Add actor-critic architecture
- Implement GAT
- Add action sampling
- Add value function

# 4. Enhance gat.py
- Add multi-head attention
- Implement graph construction
- Add layer normalization
- Add residual connections

# 5. Enhance ppo.py
- Add PPO clipping
- Implement GAE
- Add value function loss
- Add entropy bonus

2. Second Phase: xApp

3. Third Phase: gNB Implementation
// 1. Create resource slicing control
- Implement PRB allocation
- Add QoS monitoring
- Add proper error handling

// 2. Create transmission time scheduling
- Implement active/sleep periods
- Add proper synchronization
- Add proper error handling

// 3. Create monitoring system
- Add KPM collection
- Add MAC metrics collection
- Add proper logging